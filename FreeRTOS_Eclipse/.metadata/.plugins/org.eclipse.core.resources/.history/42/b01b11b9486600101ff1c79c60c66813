/**********************************************************************************************
 *
 * Module: GPIO
 *
 * File Name: GPIO.c
 *
 * Description: Source file for the TM4C123GH6PM DIO driver for TivaC Built-in Buttons and LEDs
 *
 * Author: Edges for Training Team
 *
 ***********************************************************************************************/
#include "gpio.h"
#include "tm4c123gh6pm_registers.h"

static volatile void (*g_GPIOPortFCallBackPtr)(void);
static volatile void (*g_GPIOPortBCallBackPtr)(void);

void GPIOPortF_Handler(void)
{
    (* g_GPIOPortFCallBackPtr)();
}


void GPIOPortF_SetCallBack(volatile void (*Ptr2Func) (void))
{
    g_SysTickCallBackPtr = Ptr2Func;
}

void GPIO_ExternalLedsInit(void)
{
    SYSCTL_RCGCGPIO_REG |= 0x08;  // Bit 3 for Port D
    while (!(SYSCTL_PRGPIO_REG & 0x08));  // Wait until Port D is ready

    // Disable analog on PD1, PD2, PD3
    GPIO_PORTD_AMSEL_REG &= ~((1 << 1) | (1 << 2) | (1 << 3));

    // Set PD1, PD2, PD3 as GPIO
    GPIO_PORTD_PCTL_REG &= ~((0xF << 4) | (0xF << 8) | (0xF << 12));

    // Set PD1, PD2, PD3 as outputs
    GPIO_PORTD_DIR_REG |= (1 << 1) | (1 << 2) | (1 << 3);

    // Disable alternate functions
    GPIO_PORTD_AFSEL_REG &= ~((1 << 1) | (1 << 2) | (1 << 3));

    // Enable digital function on PD1, PD2, PD3
    GPIO_PORTD_DEN_REG |= (1 << 1) | (1 << 2) | (1 << 3);

    // Initially turn off LEDs (clear outputs)
    GPIO_PORTD_DATA_REG &= ~((1 << 1) | (1 << 2) | (1 << 3));
}
void GPIO_ExternalButtonInit(void)
{
    // Enable clock for PORTB and wait for it to be ready
    SYSCTL_RCGCGPIO_REG |= 0x02;
    while(!(SYSCTL_PRGPIO_REG & 0x02));

    // Disable analog on PB2
    GPIO_PORTB_AMSEL_REG &= ~(1 << 2);

    // Clear alternate function for PB2 (set as GPIO)
    GPIO_PORTB_AFSEL_REG &= ~(1 << 2);

    // Set PB2 as input
    GPIO_PORTB_DIR_REG &= ~(1 << 2);

    // Enable pull-up resistor on PB2
    GPIO_PORTB_PUR_REG |= (1 << 2);

    // Enable digital function for PB2
    GPIO_PORTB_DEN_REG |= (1 << 2);
}
void GPIO_BuiltinButtonsLedsInit(void)
{
    /*
     * PF0 --> SW2
     * PF1 --> Red LED
     * PF2 --> Blue LED
     * PF3 --> Green LED
     * PF4 --> SW1
     */

    /* Enable clock for PORTF and wait for clock to start */
    SYSCTL_RCGCGPIO_REG |= 0x20;
    while(!(SYSCTL_PRGPIO_REG & 0x20));

    GPIO_PORTF_LOCK_REG   = 0x4C4F434B;                       /* Unlock the GPIO_PORTF_CR_REG */
    GPIO_PORTF_CR_REG    |= (1<<0);                           /* Enable changes on PF0 */
    GPIO_PORTF_AMSEL_REG &= 0xE0;                             /* Disable Analog on PF0, PF1, PF2, PF3 and PF4 */
    GPIO_PORTF_PCTL_REG  &= 0xFFF00000;                       /* Clear PMCx bits for PF0, PF1, PF2, PF3 and PF4 to use it as GPIO pins */
    GPIO_PORTF_DIR_REG   &= ~(1<<0) & ~(1<<4);                /* Configure PF0 & PF4 as input pins */
    GPIO_PORTF_DIR_REG   |= ((1<<1) | (1<<2) | (1<<3));       /* Configure PF1, PF2 & PF3 as output pins */
    GPIO_PORTF_AFSEL_REG &= 0xE0;                             /* Disable alternative function on PF0, PF1, PF2, PF3 and PF4 */
    GPIO_PORTF_PUR_REG   |= ((1<<0)|(1<<4));                  /* Enable pull-up on PF0 & PF4 */
    GPIO_PORTF_DEN_REG   |= 0x1F;                             /* Enable Digital I/O on PF0, PF1, PF2, PF3 and PF4 */
    GPIO_PORTF_DATA_REG  &= ~(1<<1) & ~(1<<2) & ~(1<<3);      /* Clear bits 1, 2 & 3 in Data register to turn off the LEDs */
}

void GPIO_RedLedOn(uint8 led_id)
{
    switch (led_id)
    {
    case BUILT_IN_LED:
        GPIO_PORTF_DATA_REG |= (1 << 1);  /* Red LED ON (Port F) */
        break;
    case EXTERNAL_LED:
        GPIO_PORTD_DATA_REG |= (1 << 1);  /* Red LED ON (Port D) */
        break;
    }
}

void GPIO_RedLedOff(uint8 led_id)
{
    switch (led_id)
    {
    case BUILT_IN_LED:
        GPIO_PORTF_DATA_REG &= ~(1 << 1);  /* Red LED OFF (Port F) */
        break;
    case EXTERNAL_LED:
        GPIO_PORTD_DATA_REG &= ~(1 << 1);  /* Red LED OFF (Port D) */
        break;
    }
}

void GPIO_BlueLedOn(uint8 led_id)
{
    switch (led_id)
    {
    case BUILT_IN_LED:
        GPIO_PORTF_DATA_REG |= (1 << 2);  /* Blue LED ON (Port F) */
        break;
    case EXTERNAL_LED:
        GPIO_PORTD_DATA_REG |= (1 << 2);  /* Blue LED ON (Port D) */
        break;
    }
}

void GPIO_BlueLedOff(uint8 led_id)
{
    switch (led_id)
    {
    case BUILT_IN_LED:
        GPIO_PORTF_DATA_REG &= ~(1 << 2);  /* Blue LED OFF (Port F) */
        break;
    case EXTERNAL_LED:
        GPIO_PORTD_DATA_REG &= ~(1 << 2);  /* Blue LED OFF (Port D) */
        break;
    }
}

void GPIO_BlueLedToggle(uint8 led_id)
{
    switch (led_id)
    {
    case BUILT_IN_LED:
        GPIO_PORTF_DATA_REG ^= (1 << 2);  /* Blue LED Toggle (Port F) */
        break;
    case EXTERNAL_LED:
        GPIO_PORTD_DATA_REG ^= (1 << 2);  /* Blue LED Toggle (Port D) */
        break;
    }
}


void GPIO_GreenLedOn(uint8 led_id)
{
    switch (led_id)
    {
    case BUILT_IN_LED:
        GPIO_PORTF_DATA_REG |= (1 << 3);  /* Green LED ON (Port F) */
        break;
    case EXTERNAL_LED:
        GPIO_PORTD_DATA_REG |= (1 << 3);  /* Green LED ON (Port D) */
        break;
    }
}

void GPIO_GreenLedOff(uint8 led_id)
{
    switch (led_id)
    {
    case BUILT_IN_LED:
        GPIO_PORTF_DATA_REG &= ~(1 << 3);  /* Green LED OFF (Port F) */
        break;
    case EXTERNAL_LED:
        GPIO_PORTD_DATA_REG &= ~(1 << 3);  /* Green LED OFF (Port D) */
        break;
    }
}

void GPIO_GreenLedToggle(uint8 led_id)
{
    switch (led_id)
    {
    case BUILT_IN_LED:
        GPIO_PORTF_DATA_REG ^= (1 << 3);  /* Green LED Toggle (Port F) */
        break;
    case EXTERNAL_LED:
        GPIO_PORTD_DATA_REG ^= (1 << 3);  /* Green LED Toggle (Port D) */
        break;
    }
}


uint8 GPIO_SW1GetState(void)
{
    return ((GPIO_PORTF_DATA_REG >> 4) & 0x01);
}

uint8 GPIO_SW2GetState(void)
{
    return ((GPIO_PORTF_DATA_REG >> 0) & 0x01);
}
uint8 GPIO_ExternalButtonGetState(void)
{
    return ((GPIO_PORTB_DATA_REG >> 2) & 0x01);
}

void GPIO_SW1EdgeTriggeredInterruptInit(void)
{
    GPIO_PORTF_IS_REG    &= ~(1<<4);      /* PF4 detect edges */
    GPIO_PORTF_IBE_REG   &= ~(1<<4);      /* PF4 will detect a certain edge */
    GPIO_PORTF_IEV_REG   &= ~(1<<4);      /* PF4 will detect a falling edge */
    GPIO_PORTF_ICR_REG   |= (1<<4);       /* Clear Trigger flag for PF4 (Interrupt Flag) */
    GPIO_PORTF_IM_REG    |= (1<<4);       /* Enable Interrupt on PF4 pin */
    /* Set GPIO PORTF priority as 5 by set Bit number 21, 22 and 23 with value 2 */
    NVIC_PRI7_REG = (NVIC_PRI7_REG & GPIO_PORTF_PRIORITY_MASK) | (GPIO_PORTF_INTERRUPT_PRIORITY<<GPIO_PORTF_PRIORITY_BITS_POS);
    NVIC_EN0_REG         |= 0x40000000;   /* Enable NVIC Interrupt for GPIO PORTF by set bit number 30 in EN0 Register */
}

void GPIO_SW2EdgeTriggeredInterruptInit(void)
{
    GPIO_PORTF_IS_REG    &= ~(1<<0);      /* PF0 detect edges */
    GPIO_PORTF_IBE_REG   &= ~(1<<0);      /* PF0 will detect a certain edge */
    GPIO_PORTF_IEV_REG   &= ~(1<<0);      /* PF0 will detect a falling edge */
    GPIO_PORTF_ICR_REG   |= (1<<0);       /* Clear Trigger flag for PF0 (Interrupt Flag) */
    GPIO_PORTF_IM_REG    |= (1<<0);       /* Enable Interrupt on PF0 pin */
    /* Set GPIO PORTF priority as 5 by set Bit number 21, 22 and 23 with value 2 */
    NVIC_PRI7_REG = (NVIC_PRI7_REG & GPIO_PORTF_PRIORITY_MASK) | (GPIO_PORTF_INTERRUPT_PRIORITY<<GPIO_PORTF_PRIORITY_BITS_POS);
    NVIC_EN0_REG         |= 0x40000000;   /* Enable NVIC Interrupt for GPIO PORTF by set bit number 30 in EN0 Register */
}

void GPIO_ExternalButtonEdgeTriggeredInterruptInit(void)
{
    // Edge-sensitive (detect edges, not levels)
    GPIO_PORTB_IS_REG    &= ~(1<<2);      /* PB2 detect edges */
    // Not both edges, so select single edge
    GPIO_PORTB_IBE_REG   &= ~(1<<2);      /* PB2 will detect a certain edge */
    // Select falling edge (high-to-low transition)
    GPIO_PORTB_IEV_REG   &= ~(1<<2);      /* PB2 will detect a falling edge */
    // Clear any prior interrupt
    GPIO_PORTB_ICR_REG   |= (1<<2);       /* Clear Trigger flag for PB2 */
    // Enable interrupt on PB2
    GPIO_PORTB_IM_REG    |= (1<<2);       /* Enable Interrupt on PB2 */

    // Set GPIO PORTB interrupt priority to 5 (bits 21:23 in NVIC_PRI0_REG)
    NVIC_PRI0_REG = (NVIC_PRI0_REG & GPIO_PORTB_PRIORITY_MASK) |
            (GPIO_PORTB_INTERRUPT_PRIORITY << GPIO_PORTB_PRIORITY_BITS_POS);

    // Enable NVIC interrupt for GPIO PORTB (Interrupt #1, so bit 1 in EN0)
    NVIC_EN0_REG |= 0x00000002;

}
